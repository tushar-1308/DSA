PE Ratio < 15 AND PEG ratio < 0.5 AND PE Ratio > 0 AND MCAP > 2000 AND Current Price < 200
QUICK SORT

(1)

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void swap(int *arr, int partitionIndex, int i){
    int temp = arr[partitionIndex];
    arr[partitionIndex] = arr[i];
    arr[i] = temp;
}

int Partition(int *arr, int start, int end){
    int pivot = arr[end];
    int partitionIndex = start;
    for(int i=start; i<end; i++){
        if(arr[i]<=pivot){
            // int temp = arr[i];
            // arr[i] = arr[partitionIndex];
            // arr[partitionIndex] = temp;
            swap(arr, partitionIndex, i);
            partitionIndex++;
        }
    }
    // int temp = arr[end];
    // arr[end] = arr[partitionIndex];
    // arr[partitionIndex] = temp;
    swap(arr, partitionIndex, end);
    return partitionIndex;
}

void Quicksort(int *arr, int start, int end){
    if(start<end){
        int partitionind = Partition(arr, start, end);
        Quicksort(arr, start, partitionind-1);
        Quicksort(arr, partitionind+1, end);
    }
}

int main() {
    int arr[] = {14,33,27,10,35,19,42,44};
    Quicksort(arr, 0, 7);
    for(int i=0; i<8; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}

(2)

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void swap(int *arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

int Partition(int *arr, int start, int end){
    int pivot = arr[end];
    int partitionIndex = start;
    for(int i=start; i<end; i++){
        if(arr[i]<=pivot){
            swap(arr, i, partitionIndex);
            partitionIndex++;
        }
    }
    swap(arr, partitionIndex, end);
    return partitionIndex;
}

void Quicksort(int *arr, int start, int end){
    if(start<end){
        int partitionIndex = Partition(arr, start, end);
        Quicksort(arr, start, partitionIndex-1);
        Quicksort(arr, partitionIndex+1, end);
    }
}

int main() {
    int arr[] = {14,33,27,10,35,19,42,44};
    Quicksort(arr, 0, 7);
    for(int i=0; i<8; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}


(3 - without even any hint, wrote after approx 1 month)

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int Partition(int *arr, int min, int max){
    int pivot = arr[max];
    int pivotInd = max;
    int startind = min;
    for(int i=min; i<pivotInd; i++){
        if(arr[i]<=pivot){
            int temp = arr[startind];
            arr[startind] = arr[i];
            arr[i] = temp;
            startind++;
        }
    }
    int temp = arr[startind];
    arr[startind] = arr[pivotInd];
    arr[pivotInd] = temp;
    
    return startind;
}

void QuickSort(int *arr, int min, int max){
    if(min<max){
        int PartitionInd = Partition(arr, min, max);
        QuickSort(arr, min, PartitionInd-1);
        QuickSort(arr, PartitionInd+1, max);
    }
}

int main() {
    int arr[] = {1,31,9,74,96,15,65,0,50,3};
    QuickSort(arr, 0, 9);
    for(int i=0; i<=9; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}


MERGE SORT

(1)

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Merge(int *arr, int left, int mid, int right){
    int firstarrlen = mid-left+1;
    int secarrlen = right-mid;
    
    int firstarr[firstarrlen];
    int secarr[secarrlen];
    
    for(int i=0; i<firstarrlen; i++){
        firstarr[i] = arr[left+i];
    }
    for(int i=0; i<secarrlen; i++){
        secarr[i] = arr[mid+1+i];
    }
    
    int firstarrind = 0;
    int secarrind = 0;
    int mergearrind = left;
    
    while (firstarrind < firstarrlen && secarrind < secarrlen) {
        if (firstarr[firstarrind] <= secarr[secarrind]) {
            arr[mergearrind] = firstarr[firstarrind];
            firstarrind++;
        }
        else {
            arr[mergearrind] = secarr[secarrind];
            secarrind++;
        }
        mergearrind++;
    }
    // Copy the remaining elements of
    // left[], if there are any
    while (firstarrind < firstarrlen) {
        arr[mergearrind] = firstarr[firstarrind];
        firstarrind++;
        mergearrind++;
    }
    // Copy the remaining elements of
    // right[], if there are any
    while (secarrind < secarrlen) {
        arr[mergearrind] = secarr[secarrind];
        secarrind++;
        mergearrind++;
    }
}

void Mergesort(int *arr, int start, int end){
    if(start<end){
        int mid = start + (end-start)/2;
        Mergesort(arr, start, mid);
        Mergesort(arr, mid+1, end);
        Merge(arr, start, mid, end);
    }
}

int main() {
    int arr[] = {14,33,27,10,35,19,42,44};
    Mergesort(arr, 0, 7);
    for(int i=0; i<8; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}

(2)

#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void Merge(int *arr, int left, int mid, int right){
    int firstarrlen = mid-left+1;
    int secarrlen = right-mid;
    
    int firstarr[firstarrlen];
    int secarr[secarrlen];
    
    for(int i=0; i<firstarrlen; i++){
        firstarr[i] = arr[left+i];
    }
    for(int i=0; i<secarrlen; i++){
        secarr[i] = arr[mid+1+i];
    }
    
    int firstarrind = 0;
    int secarrind = 0;
    int mergearrind = left;
    
    while(firstarrind<firstarrlen && secarrind<secarrlen){
        if(firstarr[firstarrind]<=secarr[secarrind]){
            arr[mergearrind] = firstarr[firstarrind];
            firstarrind++;
        }
        else{
            arr[mergearrind] = secarr[secarrind];
            secarrind++;
        }
        mergearrind++;
    }
    while(firstarrind<firstarrlen){
        arr[mergearrind] = firstarr[firstarrind];
        firstarrind++;
        mergearrind++;
    }
    while(secarrind<secarrlen){
        arr[mergearrind] = secarr[secarrind];
        secarrind++;
        mergearrind++;
    }
}

void Mergesort(int *arr, int begin, int end){
    if(begin<end){
        int mid = begin + (end-begin)/2;
        Mergesort(arr, begin, mid);
        Mergesort(arr, mid+1, end);
        Merge(arr, begin, mid, end);
    }
}

int main() {
    int arr[] = {14,33,27,10,35,19,42,44};
    Mergesort(arr, 0, 7);
    for(int i=0; i<8; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}

(3 - without even any hint, wrote after approx 1 month)

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Merge(int *arr, int min, int mid, int max){
    int firstarrlen = mid-min+1;
    int secarrlen = max-mid;
    
    int firstarr[firstarrlen];
    int secarr[secarrlen];
    
    int firstarrind=0;
    int secarrind=0;
    
    // cout<<min<<" "<<mid<<" "<<max<<endl;
    for(int i=min; i<min+firstarrlen; i++){
        firstarr[firstarrind] = arr[i];
        firstarrind++;
    }
    // for(int i=0; i<firstarrlen; i++){
    //     cout<<firstarr[i]<<" ";
    // }
    // cout<<endl;
    for(int i=mid+1; i<=max; i++){
        secarr[secarrind] = arr[i];
        secarrind++;
    }
    // for(int i=0; i<secarrlen; i++){
    //     cout<<secarr[i]<<" ";
    // }
    // cout<<endl;
    
    firstarrind=0;
    secarrind=0;
    while(firstarrind<firstarrlen && secarrind<secarrlen && min<max){
        if(firstarr[firstarrind]<=secarr[secarrind]){
            arr[min]=firstarr[firstarrind];
            firstarrind++;
            min++;
        }
        else{
            arr[min]=secarr[secarrind];
            secarrind++;
            min++;
        }

    }
    while(firstarrind<firstarrlen && min<=max){
        arr[min]=firstarr[firstarrind];
        firstarrind++;
        min++;
    }
    while(secarrind<secarrlen && min<=max){
        arr[min]=secarr[secarrind];
        secarrind++;
        min++;
    }
    // for(int i=0; i<=9; i++){
    //     cout<<arr[i]<<" ";
    // }
    // cout<<endl<<endl;
}

void MergeSort(int *arr, int min, int max){
    int mid = (min+max)/2;
    if(min<max){
        MergeSort(arr, min, mid);
        MergeSort(arr, mid+1, max);
        Merge(arr, min, mid, max);
    }
}

int main() {
    int arr[] = {1,31,9,74,96,15,65,0,50,3};
    for(int i=0; i<=9; i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
    MergeSort(arr, 0, 9);
    for(int i=0; i<=9; i++){
        cout<<arr[i]<<" ";
    }
    return 0;
}



// Recursion -  Subsets problem

#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void printSubset(vector<int> input, vector<int> output, int index){
    if(index>=input.size()){
        for(auto i: output){
            cout<<i<<" ";
        }
        cout<<endl;
        return;
    }
    
    printSubset(input, output, index+1);
    
    output.push_back(input[index]);
    printSubset(input, output, index+1);
}

int main() {
    int n;
    cout << "Enter the number of elems: "<<endl;
    cin>>n;
    vector<int> vect(n);
    vector<int> subset;
    cout<<"Enter the elements: "<<endl;
    for(int i=0; i<n; i++){
        cin>>vect[i];
    }
    cout<<"Sets are as follows: "<<endl;
    printSubset(vect, subset, 0);
    return 0;
}



// Recursion - Jumping stairs

// Online C++ compiler to run C++ program online
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

int noOfWays(int n){
    if(n<0){
        return 0;
    }
    if(n==0){
        return 1;
    }
    return noOfWays(n-1) + noOfWays(n-2) + noOfWays(n-3);
}

int main() {
    int n;
    cout << "Enter the number of stairs: "<<endl;
    cin>>n;
    cout << "Number of Ways: "<<endl;
    cout<<noOfWays(n);
    return 0;
}


// Recursion - string subset problem

#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void printSubset(string input, string output, int index){
    if(index>=input.size()){
        cout<<output<<endl;
        return;
    }
    
    printSubset(input, output, index+1);
    
    output += input[index];
    printSubset(input, output, index+1);
}

int main() {
    string str;
    cout<<"Enter the string: "<<endl;
    cin>>str;

    string output = "";
    cout<<"Sets are as follows: "<<endl;
    printSubset(str, output, 0);
    return 0;
}



// Recursion - string permutation problem

#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void getPerm(string str, int index){
    if(index>=str.size()){
        cout<<str<<endl;
    }
    
    for(int i=index; i<str.size(); i++){
        swap(str[i], str[index]);
        getPerm(str, index+1);
        // backtrack
        swap(str[i], str[index]);
    }
}

int main() {
    string str;
    cout << "Enter the string: ";
    cin>>str;
    getPerm(str, 0);
    return 0;
}


// Recursion - Tower of Hanoi

#include<iostream>
using namespace std;

void toh(int n, char source, char dest, char help){
    
    if(n==0){
        return;
    }
    toh(n-1, source, help, dest);
    cout<<n<<" "<<source<<" -> "<<dest<<endl;
    toh(n-1, help, dest, source);
    
  }


int  main() {

    int n;
    cout<<"Tower names are a, b, c"<<endl;
    cout<<"Enter total slabs: ";
    cin>>n;
    // char source,dest,help;
    // cin>>source>>dest>>help;
    // toh(n, source, dest, help);
    toh(n, 'a', 'b', 'c');
  }



// Recursion - print keyboard combination

// Online C++ compiler to run C++ program online
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void getkeycomb(int input, string output, vector<vector<char>> vect, int index){
    if(index==to_string(input).size()){
        cout<<output<<endl;
        return;
    }
    char ch = to_string(input)[index];
    for(int i=0; i<vect[ch - '0'].size(); i++){
        getkeycomb(input, output + vect[ch - '0'][i], vect, index+1);
    }
}

int main() {
    int number;
    cout << "Enter the number: ";
    cin>>number;
    vector<vector<char>> vect = {
        {'.',';'},
        {'a','b','c'},
        {'d','e','f'},
        {'g','h','i'},
        {'j','k','l'},
        {'m','n','o'},
        {'p','q','r','s'},
        {'t','u'},
        {'v','w','x'},
        {'y','z'}
    };
    string output="";
    getkeycomb(number, output, vect, 0);
    return 0;
}



// RECURSION - PRINT STAIRS PATH

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void getStairPath(int n, string path){
    
    if(n<0){
        return;
    }
    if(n==0){
        cout<<path<<" ";
    }
    getStairPath(n-1, '1' + path);
    getStairPath(n-2, '2' + path);
    getStairPath(n-3, '3' + path);

}

int main() {
    int n;
    cout <<"Enter the stair number: ";
    cin>>n;
    string path;
    path = "";
    getStairPath(n, path);
    return 0;
}



// RECURSION - PRINT MAZE PATH

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void getMazePath(int srow, int scol, int row, int col, string path){
    
    if(srow>row || scol>col){
        return;
    }
    if(srow==row && scol==col){
        cout<<path<<" ";
        return;
    }
    
    getMazePath(srow+1, scol, row, col, 'v' + path);
    getMazePath(srow, scol+1, row, col, 'h' + path);
    
}

int main() {
    int row, col;
    cout <<"Enter the ending row & col: ";
    cin>>row>>col;
    string path = "";
    getMazePath(1, 1, row, col, path);
    return 0;
}



// RECURSION - PRINT MAZE PATH WITH JUMP


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void getMazePath(int srow, int scol, int row, int col, string path){
    
    if(srow>row || scol>col){
        return;
    }
    if(srow==row && scol==col){
        cout<<path<<" ";
        return;
    }
    
    for(int i=1; i<=row-srow; i++){
        getMazePath(srow+i, scol, row, col, 'v' + to_string(i) + path);
    }
    
    for(int i=1; i<=row-srow && col-scol; i++){
        getMazePath(srow+i, scol+i, row, col, 'd' + to_string(i) + path);
    }
    
    for(int i=1; i<=col-scol; i++){
        getMazePath(srow, scol+i, row, col, 'h' + to_string(i) + path);
    }
    
}

int main() {
    int row, col;
    cout <<"Enter the ending row & col: ";
    cin>>row>>col;
    string path = "";
    getMazePath(1, 1, row, col, path);
    return 0;
}





// RECURSION - ENCODING

#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void encoding(string input, vector<char> code, string output){
    if(input.size()==0){
        cout<<output<<endl;
        return;
    }
    if(input.size()==1){
        char ch = input[0];
        string nowstr = input.substr(1);
        int val = ch - '0';
        encoding(nowstr, code, output + code[val-1]);
    }
    else{
        char ch = input[0];
        string nowstr = input.substr(1);
        if(ch=='0'){
            return;
        }
        else{
            int val = ch - '0';
            encoding(nowstr, code, output + code[val-1]);
        
            string ch12 = input.substr(0,2);
            string str12 = input.substr(2);
            int val12 = stoi(ch12);
            if(val12<=26){
                encoding(str12, code, output + code[val12-1]);
            }
        }
    }
}

int main() {
    vector<char> code;
    code = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
    string input;
    string output="";
    cout<<"Enter the string: ";
    cin>>input;
    encoding(input, code, output);
    return 0;
}



// RECURSION - FLOOD FILL 


#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void floodfill(int srow, int scol, int row, int col, vector<vector<int>> maze, string path, vector<vector<int>> visited){
    // top, left, bottom, right = t,l,b,r
    
    if(srow<0 || scol<0 || srow==row+1 || scol==col+1 || maze[srow][scol]==1 || visited[srow][scol]==1){
        return;
    }
    
    if(srow==row && scol==col){
        cout<<path<<" ";
        return;
    }
    visited[srow][scol]=1;
    floodfill(srow-1, scol, row, col, maze, path + 't',visited);
    floodfill(srow, scol-1, row, col, maze, path + 'l',visited);
    floodfill(srow+1, scol, row, col, maze, path + 'b',visited);
    floodfill(srow, scol+1, row, col, maze, path + 'r',visited);
    visited[srow][scol]=0;
}

int main() {
    int row, col;
    cout<<"Enter the no of row & col: ";
    cin>>row>>col;
    cout<<row<<" "<<col<<endl;
    string path="";
    
    // for(int i=0; i<row+1; i++){
    //     for(int j=0; j<col+1; j++){
    //         cout<<j<<" ";
    //     }
    //     cout<<endl;
    // }
    
    // int* maze = new int[row+1][col+1];
    // int maze[row+1][col+1];
    vector<vector<int>> maze{
        {0,1,0,0,0,0,0},
        {0,1,0,1,1,1,0},
        {0,0,0,0,0,0,0},
        {1,0,1,1,0,1,1},
        {1,0,1,1,0,1,1},
        {1,0,0,0,0,0,0}
    };
    vector<vector<int>> visited{
        {0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0}
    };
    // for(int i=0; i<row+1; i++){
    //     vector<int> vect(col+1);
    //     for(int j=0; j<col+1; j++){
    //         cin>>vect[j];
    //     }
    //     maze.push_back(vect);
    // }
    floodfill(0, 0, row, col, maze, path, visited);
    return 0;
}





// RECURSION - TARGET SUM



#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void targetSumSubset(vector<int> arr, string set, int idx, int tarsum, int sum){
    
    
    if(idx==arr.size()){
        if(sum==tarsum){
            cout<<set<<endl;
        }
        return;
    }
    
    targetSumSubset(arr, set+to_string(arr[idx]) + " ", idx+1, tarsum, sum+arr[idx]);
    targetSumSubset(arr, set, idx+1, tarsum, sum);
}

int main() {
    int n;
    string set = "";
    cout<<"Enter total no of numbers: ";
    cin>>n;
    cout<<"Enter the numbers: ";
    vector<int> arr(n);
    for(int i=0; i<n; i++){
        cin>>arr[i];
    }
    cout<<"Enter the target number: ";
    int tarsum;
    cin>>tarsum;
    targetSumSubset(arr, set, 0, tarsum, 0);
}



// RECURSION - N QUEEN PROBLEM


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool isQueenSafe(vector<vector<int>> chess, int row, int col){
    for(int i=row-1, j=col; i>=0; i--){
        if(chess[i][j]==1){
            return false;
        }
    }
    for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){
        if(chess[i][j]==1){
            return false;
        }
    }
    for(int i=row-1, j=col+1; i>=0 && j<chess.size(); i--, j++){
        if(chess[i][j]==1){
            return false;
        }
    }
    return true;
}

void nQueenProblem(vector<vector<int>> chess, int row, string answer){
    if(row == chess.size()){
        cout<<answer<<endl;
        return;
    }
    for(int col=0; col<chess.size(); col++){
        if(isQueenSafe(chess, row, col) == true){
            chess[row][col]=1;
            nQueenProblem(chess, row+1, answer + to_string(row) + "-" + to_string(col) + ", ");
            chess[row][col]=0;
        }
    }
}

int main() {
    int n;
    string answer = "";
    cout<<"Enter number of queens & size of chess board: ";
    cin>>n;
    vector<vector<int>> chess(n, vector<int> (n));
    nQueenProblem(chess, 0, answer);
}




// RECURSION - KNIGHTS TOUR PROBLEM


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void displayTour(vector<vector<int>> chess){
    for(int i=0; i<chess.size(); i++){
        for(int j=0; j<chess.size(); j++){
            cout<<chess[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
}

void knightsTour(vector<vector<int>> chess, int row, int col, int move){
    
    if(row < 0 || col<0 || row>=chess.size() || col>=chess.size() || chess[row][col]>0){
        return;
    }
    else if(move==chess.size()*chess.size()){
        chess[row][col]=move;
        displayTour(chess);
        chess[row][col]=0;
        return;
    }
    chess[row][col] = move;
    knightsTour(chess, row-2, col+1, move+1);
    knightsTour(chess, row-1, col+2, move+1);
    knightsTour(chess, row+1, col+2, move+1);
    knightsTour(chess, row+2, col+1, move+1);
    knightsTour(chess, row+2, col-1, move+1);
    knightsTour(chess, row+1, col-2, move+1);
    knightsTour(chess, row-1, col-2, move+1);
    knightsTour(chess, row-2, col-1, move+1);
    chess[row][col]=0;
}

int main() {
    int n;
    // string answer = "";
    cout<<"Enter the size of chess board: ";
    cin>>n;
    int row,col;
    cout<<"Enter the initial position of knight: ";
    cin>>row>>col;
    vector<vector<int>> chess(n, vector<int> (n, 0));
    knightsTour(chess, row, col, 1);
    cout<<"THE END";
}



// RECURSION - PERMUTATION - I


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Permutation(int r, int cr, vector<int> answer, vector<int> vect){
    
    if(cr>r){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i]<<" ";
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<vect.size(); i++){
        if(vect[i]==0){
            vect[i]=1;
            answer[i] = cr;
            Permutation(r, cr+1, answer, vect);
            answer[i] = 0;
            vect[i]=0;
        }
    }
}

int main() {
    int n,r;
    cout<<"Enter the no of boxes and selection: ";
    cin>>n>>r;
    vector<int> vect(n,0);
    vector<int> answer(n,0);
    Permutation(r, 1, answer, vect);
    return 0;
}



// RECURSION - COMBINATION - I


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Combination(int n, int r, int cr, int index, string answer){
    
    if(index==n){
        if(cr==r){
            cout<<answer<<endl;
        }
        return;
    }
    

    Combination(n, r, cr+1, index+1, answer+'i');
    Combination(n, r, cr, index+1, answer+'-');

}

int main() {
    int n,r;
    cout<<"Enter the no of boxes and selection: ";
    cin>>n>>r;
    string answer = "";
    Combination(n, r, 0, 0, answer);
    return 0;
}




// RECURSION - PERMUTATION - II


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Permutation(int n, int ts, int cs, int index, string answer, vector<int> vect){
    
    if(index>n){
        if(cs==ts){
            cout<<answer<<endl;
        }
        return;
    }
    
    
    for(int i=0; i<ts; i++){
        if(vect[i]==0){
            vect[i]=1;
            Permutation(n, ts, cs+1, index+1, answer+to_string(i+1), vect);
            vect[i]=0;
            
        }
    }
    Permutation(n, ts, cs, index+1, answer+'-', vect);
}

int main() {
    int n,r;
    cout<<"Enter the no of boxes and selection: ";
    cin>>n>>r;
    string answer = "";
    vector<int> vect(r,0);
    Permutation(n, r, 0, 1, answer, vect);
    return 0;
}



// RECURSION - COMBINATION - II



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Combination(int n, int ts, int cs, int index, vector<int> vect){
    
    if(cs==ts){
        for(int i=0; i<vect.size(); i++){
            if(vect[i]){
                cout<<"i";
            }
            else{
                cout<<"-";
            }
        }
        cout<<endl;
        return;
    }

    
    for(int i=index; i<n; i++){
        vect[i]=1;
        Combination(n, ts, cs+1, i+1, vect);
        vect[i]=0;
    }
}

int main() {
    int n,r;
    cout<<"Enter the no of boxes and selection: ";
    cin>>n>>r;
    vector<int> vect(n,0);
    Combination(n, r, 0, 0, vect);
    return 0;
}



// RECURSION - PERMUTATION - I in 2D - ITEM CHOOSES


#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void Permutation1(int n, int ts, int cs, vector<vector<int>> vect){
    
    if(cs==ts){
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cout<<vect[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            if(vect[i][j]==0){
                vect[i][j]=1;
                Permutation1(n, ts, cs+1, vect);
                vect[i][j]=0;
            }
        }
    }
}

int main() {
    int n,r;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n>>r;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    Permutation1(n, r, 0, vect);
    return 0;
}



// RECURSION - COMBINATION - I in 2D - BOX CHOOSES


#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void Combination1(int n, int ts, int cs, int cr, int cc, vector<vector<int>> vect){
   
    if(cs==ts){
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(vect[i][j]){
                    cout<<"i"<<" ";
                }
                else{
                    cout<<"-"<<" ";
                }
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    if(cc==n){
        cr+=1;
        cc=0;
    }
    
    if(cr==n){
        return;
    }
    
    vect[cr][cc]=1;
    Combination1(n, ts, cs+1, cr, cc+1, vect);
    vect[cr][cc]=0;   
    Combination1(n, ts, cs, cr, cc+1, vect);
}

int main() {
    int n,r;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n>>r;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    Combination1(n, r, 0, 0, 0, vect);
    return 0;
}




// RECURSION - PERMUTATION - II in 2D - NOT WORKING CORRECT - BOX CHOOSES



#include <iostream>
#include<bits/stdc++.h>
using namespace std;

void Permutation2(int n, int ts, int cs, int cr, int cc, int index, vector<vector<int>> vect){

    if(index==n*n){
        if(cs==ts){
            for(int i=0; i<n; i++){
                for(int j=0; j<n; j++){
                    if(vect[i][j]){
                        cout<<"i"<<" ";
                    }
                    else{
                        cout<<"-"<<" ";
                    }
                }
                cout<<endl;
            }
            cout<<endl;
            return;
        }
    }
    
    if(cc==n){
        cr+=1;
        cc=0;
    }
    
    if(cr==n){
        return;
    }
    
    Permutation2(n, ts, cs, cr, cc+1, index+1, vect);
    for(int i=0; i<ts; i++){
        vect[cr][cc]=1;
        Permutation1(n, ts, cs+1, cr, cc+1, index+1,  vect);
        vect[cr][cc]=0;   
    }
}

int main() {
    int n,r;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n>>r;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    Permutation2(n, r, 0, 0, 0, 0, vect);
    return 0;
}





// RECURSION - COMBINATION - II in 2D - ITEM CHOOSES



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Combination2(int n, int ts, int cs, int row, int col, vector<vector<int>> vect){
    
    if(cs==ts){
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cout<<vect[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=col; i<n; i++){
        if(vect[row][i]==0){
            vect[row][i]=1;
            Combination2(n, ts, cs+1, row, i+1, vect);
            vect[row][i]=0;
        }
    }
    for(int i=row+1; i<n; i++){
        for(int j=0; j<n; j++){
            if(vect[i][j]==0){
                vect[i][j]=1;
                Combination2(n, ts, cs+1, i, j+1, vect);
                vect[i][j]=0;
            }
        }
    }
}

int main() {
    int n,r;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n>>r;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    Combination2(n, r, 0, 0, 0, vect);
    return 0;
}




// RECURSION - COMBINATION - III in 2D as 1D - ITEM CHOOSES



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void Combination3(int n, int cs, int index, vector<vector<int>> vect){
    
    if(cs==n){
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cout<<vect[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=index+1; i<n*n; i++){
        int row = i/n;
        int col = i%n;
        vect[row][col]=1;
        Combination3(n, cs+1, i, vect);
        vect[row][col]=0;
    }
}



// BACKTRACKING - PLACING N DISTINCT QUEENS IN N*N BOARD AND ITS PERMUTATION - I


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool isQueenSafe(int n, int index, vector<vector<int>> vect){
    int row = index/n;
    int col = index%n;
    
    // Horizontally
    for(int i=row,j=col; j<n; j++){
        if(vect[i][j]>0){
            return false;
        }
    }
    for(int i=row,j=col; j>=0; j--){
        if(vect[i][j]>0){
            return false;
        }
    }
    // Vertically
    for(int i=row,j=col; i<n; i++){
        if(vect[i][j]>0){
            return false;
        }
    }
    for(int i=row,j=col; i>=0; i--){
        if(vect[i][j]>0){
            return false;
        }
    }
    // diagonally 1-3 quad
    for(int i=row,j=col; i>=0 & j<n; i--,j++){
        if(vect[i][j]>0){
            return false;
        }
    }
    for(int i=row,j=col; i<n & j>=0; i++,j--){
        if(vect[i][j]>0){
            return false;
        }
    }
    // diagonally 2-4 quad
    for(int i=row,j=col; i>=0 & j>=0; i--,j--){
        if(vect[i][j]>0){
            return false;
        }
    }
    for(int i=row,j=col; i<n & j<n; i++,j++){
        if(vect[i][j]>0){
            return false;
        }
    }
    return true;
}

void NQueenPerm(int n, int qp, vector<vector<int>> vect){
    
    if(qp==n){
        for(int i=0; i<vect.size(); i++){
            for(int j=0; j<vect.size(); j++){
                cout<<vect[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<n*n; i++){
        if(isQueenSafe(n, i, vect)){
            int row = i/n;
            int col = i%n;
            vect[row][col]=qp+1;
            NQueenPerm(n, qp+1, vect);
            vect[row][col]=0;
        }
    }
}

int main() {
    int n;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    NQueenPerm(n, 0, vect);
    return 0;
}




// BACKTRACKING - COMBINATION PLACING N SIMILAR QUEENS IN N*N BOARD


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool isQueenSafe(int n, int index, vector<vector<int>> vect){
    int row = index/n;
    int col = index%n;
    
    // Horizontally
    for(int i=row,j=col; j>=0; j--){
        if(vect[i][j]>0){
            return false;
        }
    }
    
    // Vertically
    for(int i=row,j=col; i>=0; i--){
        if(vect[i][j]>0){
            return false;
        }
    }
    
    // diagonally 1 quad
    for(int i=row,j=col; i>=0 & j<n; i--,j++){
        if(vect[i][j]>0){
            return false;
        }
    }
    
    // diagonally 2 quad
    for(int i=row,j=col; i>=0 & j>=0; i--,j--){
        if(vect[i][j]>0){
            return false;
        }
    }
    return true;
}

void NQueenPerm(int n, int qp, int index, vector<vector<int>> vect){
    
    if(qp==n){
        for(int i=0; i<vect.size(); i++){
            for(int j=0; j<vect.size(); j++){
                if(vect[i][j]){
                    cout<<"q"<<" ";
                }
                else{
                    cout<<vect[i][j]<<" ";
                }
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=index+1; i<n*n; i++){
        if(isQueenSafe(n, i, vect)){
            int row = i/n;
            int col = i%n;
            vect[row][col]=qp+1;
            NQueenPerm(n, qp+1, i, vect);
            vect[row][col]=0;
        }
    }
}

int main() {
    int n;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    NQueenPerm(n, 0, -1, vect);
    return 0;
}




// BACKTRACKING - PLACING N SIMILAR QUEENS IN N*N BOARD USING BRANCH & BOUND ALGO


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool isQueenSafe(int n, int row, int col, vector<vector<int>> vect, vector<int> column, vector<int> diagonal13, vector<int> diagonal24){

    if(column[col]==1 || diagonal13[row+col]==1 || diagonal24[row-col+n-1]==1){
        return false;
    }
    
    return true;
}

void NQueenBranchAndBound(int n, int qp, int row, vector<vector<int>> vect, vector<int> column, vector<int> diagonal13, vector<int> diagonal24){
    
    if(qp==n || row==n){
        for(int i=0; i<vect.size(); i++){
            for(int j=0; j<vect.size(); j++){
                if(vect[i][j]){
                    cout<<"q"<<" ";
                }
                else{
                    cout<<vect[i][j]<<" ";
                }
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    
    for(int col=0; col<n; col++){
        if(isQueenSafe(n, row, col, vect, column, diagonal13, diagonal24)){
            vect[row][col]=qp+1;
            column[col]=1;
            diagonal13[row+col]=1;
            diagonal24[row-col+n-1]=1;
            NQueenBranchAndBound(n, qp+1, row+1, vect, column, diagonal13, diagonal24);
            vect[row][col]=0;
            column[col]=0;
            diagonal13[row+col]=0;
            diagonal24[row-col+n-1]=0;
        }
    }
}

int main() {
    int n;
    cout<<"Enter the size of board and no of queens: ";
    cin>>n;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    vector<int> column(n,0);
    vector<int> diagonal13(2*n-1,0);
    vector<int> diagonal24(2*n-1,0);
    NQueenBranchAndBound(n, 0, 0, vect, column, diagonal13, diagonal24);
    return 0;
}




// RECURSION - COMBINATION PLACING N SIMILAR KNIGTS IN N*N BOARD


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool isKnightSafe(int n, int index, vector<vector<int>> vect){
    int row = index/n;
    int col = index%n;
    
    // Horizontally 1st quad
    if(row>0 && col<n-2){
        if(vect[row-1][col+2]>0){
            return false;
        }
    }
    
    // Vertically 1st quad
    if(row>1 && col<n-1)
    {
    if(vect[row-2][col+1]>0){
        return false;
    }
    }
    
    // Horizontally 2nd quad
    if(row>0 && col>1){
    if(vect[row-1][col-2]>0){
        return false;
    }
    }
    
    // Vertically 2nd quad
    if(row>1 && col>0){
    if(vect[row-2][col-1]>0){
        return false;
    }
    }
    
    return true;
}

void NKnightComb(int n, int kp, int index, vector<vector<int>> vect){
    
    if(kp==n){
        for(int i=0; i<vect.size(); i++){
            for(int j=0; j<vect.size(); j++){
                if(vect[i][j]){
                    cout<<"k"<<" ";
                }
                else{
                    cout<<vect[i][j]<<" ";
                }
            }
            cout<<endl;
        }
        cout<<endl;
        return;
    }
    
    for(int i=index+1; i<n*n; i++){
        if(isKnightSafe(n, i, vect)){
            int row = i/n;
            int col = i%n;
            vect[row][col]=kp+1;
            NKnightComb(n, kp+1, i, vect);
            vect[row][col]=0;
        }
    }
}

int main() {
    int n;
    cout<<"Enter the size of board and no of knigts: ";
    cin>>n;
    vector<vector<int>> vect(n, vector<int> (n, 0));
    NKnightComb(n, 0, -1, vect);
    return 0;
}





// BACKTRACKING - STRING PERMUTATION - I


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(int ts, int cs, unordered_map<char, int> um, string answer){
    
    if(cs==ts){
        cout<<answer<<endl;
        return;
    }
    
    unordered_map<char, int>::iterator it;
    for(auto it=um.begin(); it!=um.end(); it++){
        if(it->second>0){
            it->second-=1;
            StringPermutation(ts, cs+1, um, answer+it->first);
            it->second+=1;
        }
    }
    
}

int main() {
    string str;
    string answer="";
    cout<<"Enter the string ";
    cin>>str;
    unordered_map<char, int> um;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    StringPermutation(str.size(), 0, um, answer);
    return 0;
}





// BACKTRACKING - STRING PERMUTATION - II



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, unordered_map<char, int> indexTracker, vector<char> answer){
    
    if(cs==ts){
        for(int i=0; i<ts; i++){
            cout<<answer[i];
        }
        cout<<endl;
        return;
    }
    
    for(int i=indexTracker[str[index]]+1; i<str.size(); i++){
        if(answer[i]=='1'){
            indexTracker[str[index]]=i;
            answer[i]=str[index];
            StringPermutation(str, ts, cs+1, index+1, indexTracker, answer);
            answer[i]='1';
            indexTracker[str[index]]=-1;
        }
    }
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    vector<char> answer(str.size(),'1');
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    unordered_map<char, int> indexTracker;
    indexTracker = um;
    for(auto itr=indexTracker.begin(); itr!=indexTracker.end(); itr++){
        itr->second=-1;
    }
    
    StringPermutation(str, str.size(), 0, 0, indexTracker, answer);
    return 0;
}




// BACKTRACKING - Words K Selection - 1 | Select K Distinct Characters without Repetition using Backtracking


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, string answer){
    
    if(index==str.size()){
        if(cs==ts){
            cout<<answer<<endl;
        }
        return;
    }
    
    
    StringPermutation(str, ts, cs, index+1, answer);
    StringPermutation(str, ts, cs+1, index+1, answer+str[index]);
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        str+=itr->first;
    }
    for(int i=0; i<str.length()/2; i++){
        swap(str[i], str[str.length()-i-1]);
    }
    cout<<str<<endl<<endl;
    string answer="";

    StringPermutation(str, n, 0, 0, answer);
    return 0;
}




// BACKTRACKING - Words K Selection - 2 | Select K Distinct Characters without Repetition using Backtracking




#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, vector<char> answer){

    if(cs==ts){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i];
        }
        cout<<endl;
        return;
    }

    
    for(int i=index+1; i<str.length(); i++){
        answer.push_back(str[i]);
        StringPermutation(str, ts, cs+1, i, answer);
        answer.pop_back();
    }
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        str+=itr->first;
    }
    for(int i=0; i<str.length()/2; i++){
        swap(str[i], str[str.length()-i-1]);
    }
    cout<<str<<endl<<endl;
    vector<char> answer;

    StringPermutation(str, n, 0, -1, answer);
    return 0;
}





// BACKTRACKING - Words - K - Selection 3 | Select K Characters with Repetition using Backtracking | NOT WORKING CORRECT





#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, unordered_map<char, int> um, vector<char> answer){
    
    if(index==str.size()){
        return;
    }
    if(cs==ts){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i];
        }
        cout<<endl;
        return;
    }
    
    unordered_map<char, int>::iterator itr;
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        if(itr->second>0 && str[index]==itr->first){
            StringPermutation(str, ts, cs, index+1, um, answer);
            itr->second-=1;
            answer.push_back(itr->first);
            StringPermutation(str, ts, cs+1, index, um, answer);
            itr->second+=1;
            answer.pop_back();
        }
    }
    
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        cout<<itr->first<<" "<<itr->second<<"   ";
        str+=itr->first;
    }
    cout<<endl;
    
    cout<<str<<endl<<endl;
    vector<char> answer(n);
    itr=um.begin();
    StringPermutation(str, n, 0, 0, um, answer);
    return 0;
}





// BACKTRACKING - Words - K - Selection 4 | Select K Characters with Repetition using Backtracking




#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, unordered_map<char, int> um, vector<char> answer){
    
    if(cs==ts){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i];
        }
        cout<<endl;
        return;
    }
    
    unordered_map<char, int>::iterator itr;
    for(int i=index; i<str.size(); i++){
        if(um[str[i]]>0){
            um[str[i]]-=1;
            answer.push_back(str[i]);
            if(um[str[i]]>0){
                StringPermutation(str, ts, cs+1, i, um, answer);
            }
            else{
                StringPermutation(str, ts, cs+1, i+1, um, answer);
            }
            um[str[i]]+=1;
            answer.pop_back();
        }
    }
    
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        cout<<itr->first<<" "<<itr->second<<"   ";
        str+=itr->first;
    }
    cout<<endl;
    
    cout<<str<<endl<<endl;
    vector<char> answer(n);
    itr=um.begin();
    StringPermutation(str, n, 0, 0, um, answer);
    return 0;
}




// BACKTRACKING - K Length Words - 1 | K Length Words of Distinct Characters



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, unordered_map<char, int> um, vector<char> answer){
    
    if(index==str.length()){
        if(cs==ts){
            for(int i=0; i<answer.size(); i++){
                cout<<answer[i];
            }
            cout<<endl;
        }
        return;
    }
    
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<ts; i++){
        if(answer[i]=='1'){
            answer[i]=str[index];
            StringPermutation(str, ts, cs+1, index+1, um, answer);
            answer[i]='1';
        }
    }
    StringPermutation(str, ts, cs, index+1, um, answer);
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        cout<<itr->first<<" "<<itr->second<<"   ";
        str+=itr->first;
    }
    cout<<endl;
    
    cout<<str<<endl<<endl;
    vector<char> answer(n,'1');
    itr=um.begin();
    StringPermutation(str, n, 0, 0, um, answer);
    return 0;
}





// BACKTRACKING - K Length Words - 2 | K Length Words of Distinct Characters



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, vector<bool> indextrack, vector<char> answer){
    
    // if(index==str.length()){
        if(cs==ts){
            for(int i=0; i<answer.size(); i++){
                cout<<answer[i];
            }
            cout<<endl;
            return;
        }
        // return;
    // }
    
    for(int i=0; i<str.size(); i++){
        if(indextrack[i]==false){
            answer.push_back(str[i]);
            indextrack[i]=true;
            StringPermutation(str, ts, cs+1, indextrack, answer);
            answer.pop_back();
            indextrack[i]=false;
        }
    }
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the boxes length ";
    cin>>n;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    str="";
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        cout<<itr->first<<" "<<itr->second<<"   ";
        str+=itr->first;
    }
    cout<<endl;
    
    cout<<str<<endl<<endl;
    vector<char> answer(n);
    vector<bool> indextrack(str.size(), false);
    itr=um.begin();
    StringPermutation(str, n, 0, indextrack, answer);
    return 0;
}




// BACKTRACKING - K Length Words - 3 



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, int ts, int cs, int index, unordered_map<char, int> indexTracker, vector<char> answer){
    
    if(index==str.length()){
        if(cs==ts){
            for(int i=0; i<answer.size(); i++){
                cout<<answer[i];
            }
            cout<<endl;
            // return;
        }
        return;
    }
    
    int val=0;
    if(indexTracker[str[index]]>-1){
        val=indexTracker[str[index]]+1;
    }
    
    for(int i=val; i<answer.size(); i++){
        if(answer[i]=='1'){
            answer[i]=str[index];
            indexTracker[str[index]]=i;
            StringPermutation(str, ts, cs+1, index+1, indexTracker, answer);
            indexTracker[str[index]]=-1;
            answer[i]='1';
        }
    }
    if(val==0){
        StringPermutation(str, ts, cs, index+1, indexTracker, answer);
    }
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    unordered_map<char, int> indexTracker;
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
            indexTracker[str[i]]=-1;
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    cout<<str<<endl<<endl;
    vector<char> answer(n,'1');
    itr=um.begin();
    StringPermutation(str, n, 0, 0, indexTracker, answer);
    return 0;
}





// BACKTRACKING - K Length Words - 4 | Backtracking Interview Questions



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void StringPermutation(string str, string ustr, int ts, int cs, unordered_map<char, int> um, vector<char> answer){
    
    if(cs==ts){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i];
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<ustr.size(); i++){
        if(um[ustr[i]]>0){
            answer[cs]=ustr[i];
            um[ustr[i]]-=1;
            StringPermutation(str, ustr, ts, cs+1, um, answer);
            um[ustr[i]]+=1;
            answer[cs]='1';
        }
    }
    
}

int main() {
    string str;
    cout<<"Enter the string ";
    cin>>str;
    int n;
    cout<<"Enter the answer length ";
    cin>>n;
    
    string ustr = "";
    
    unordered_map<char, int> um;
    unordered_map<char, int>::iterator itr;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])==um.end()){
            um[str[i]]=1;
            ustr+=str[i];
        }
        else{
            um[str[i]]+=1;
        }
    }
    
    cout<<str<<" "<<ustr<<endl<<endl;
    vector<char> answer(n,'1');
    StringPermutation(str, ustr, n, 0, um, answer);
    return 0;
}



// RECURSION - Coin Change Problem - Recursion - Part 1 | Coin Change Combination - 1



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void CoinChangeProblem(int index, int count, vector<int> coins, int sum, int answer, vector<int> combinations){
    
    if(index==count){
        if(answer==sum){
            for(int i=0; i<combinations.size(); i++){
                cout<<combinations[i]<<" ";
            }
            cout<<endl;
        }
        return;
    }
    
    CoinChangeProblem(index+1, count, coins, sum, answer, combinations);
    combinations.push_back(coins[index]);
    answer+=coins[index];
    CoinChangeProblem(index+1, count, coins, sum, answer, combinations);
    answer-=coins[index];
    combinations.pop_back();
}

int main() {
    int count;
    cout<<"Enter number of coins: ";
    cin>>count;
    vector<int> coins;
    int coin;
    for(int i=0; i<count; i++){
        cin>>coin;
        coins.push_back(coin);
    }
    int sum;
    cout<<"Enter the sum: ";
    cin>>sum;
    
    vector<int> combinations;
    CoinChangeProblem(0, count, coins, sum, 0, combinations);
}




// RECURSION - Coin Change Problem - Recursion - Part 2 | Coin Change Combination - 2 Explained with Code



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void CoinChangeProblem(int index, int count, vector<int> coins, int sum, vector<int> combinations){
    
    if(index==count){
        if(sum==0){
            for(int i=0; i<combinations.size(); i++){
                cout<<combinations[i]<<" ";
            }
            cout<<endl;
        }
        return;
    }
    
    
    for(int i=sum/coins[index]; i>0; i--){
        for(int j=0; j<i; j++){
            combinations.push_back(coins[index]);
        }
        sum-=coins[index]*i;
        CoinChangeProblem(index+1, count, coins, sum, combinations);
        sum+=coins[index]*i;
        for(int j=0; j<i; j++){
            combinations.pop_back();
        }
    }
    CoinChangeProblem(index+1, count, coins, sum, combinations);
}

int main() {
    int count;
    cout<<"Enter number of coins: ";
    cin>>count;
    vector<int> coins;
    int coin;
    for(int i=0; i<count; i++){
        cin>>coin;
        coins.push_back(coin);
    }
    int sum;
    cout<<"Enter the sum: ";
    cin>>sum;
    
    vector<int> combinations;
    CoinChangeProblem(0, count, coins, sum, combinations);
}



// RECURSION - Coin Change Problem - Recursion| Coin Change Permutation- 1 Explained with Code



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void CoinChangeProblem(int count, vector<int> coins, int sum, int answer, vector<bool> coinUsedOrNot, vector<int> combinations){
    
    if(answer>sum){
        return;
    }
    
    if(sum==answer){
        for(int i=0; i<combinations.size(); i++){
            cout<<combinations[i]<<" ";
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<count; i++){
        if(coinUsedOrNot[i]==false){
            combinations.push_back(coins[i]);
            answer+=coins[i];
            coinUsedOrNot[i]=true;
            CoinChangeProblem(count, coins, sum, answer, coinUsedOrNot, combinations);
            coinUsedOrNot[i]=false;
            answer-=coins[i];
            combinations.pop_back();
        }
    }
}

int main() {
    int count;
    cout<<"Enter number of coins: ";
    cin>>count;
    vector<int> coins;
    int coin;
    for(int i=0; i<count; i++){
        cin>>coin;
        coins.push_back(coin);
    }
    int sum;
    cout<<"Enter the sum: ";
    cin>>sum;
    vector<bool> coinUsedOrNot(count, false);
    vector<int> combinations;
    CoinChangeProblem(count, coins, sum, 0, coinUsedOrNot, combinations);
}
eg.
Enter number of coins: 5
2 3 5 7 9
Enter the sum: 12
2 3 7 
2 7 3 
3 2 7 
3 7 2 
3 9 
5 7 
7 2 3 
7 3 2 
7 5 
9 3 



// RECURSION - Coin Change Permutation 2 | Recursion | Coin Change Problem



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void CoinChangeProblem(int count, vector<int> coins, int sum, int answer, vector<int> combinations){
    
    if(answer>sum){
        return;
    }
    
    if(sum==answer){
        for(int i=0; i<combinations.size(); i++){
            cout<<combinations[i]<<" ";
        }
        cout<<endl;
        return;
    }
    
    for(int i=0; i<count; i++){
        combinations.push_back(coins[i]);
        answer+=coins[i];
        CoinChangeProblem(count, coins, sum, answer, combinations);
        answer-=coins[i];
        combinations.pop_back();
    }
}

int main() {
    int count;
    cout<<"Enter number of coins: ";
    cin>>count;
    vector<int> coins;
    int coin;
    for(int i=0; i<count; i++){
        cin>>coin;
        coins.push_back(coin);
    }
    int sum;
    cout<<"Enter the sum: ";
    cin>>sum;
    vector<int> combinations;
    CoinChangeProblem(count, coins, sum, 0, combinations);
}

eg.
Enter number of coins: 3 
2 3 5
Enter the sum: 10
2 2 2 2 2 
2 2 3 3 
2 3 2 3 
2 3 3 2 
2 3 5 
2 5 3 
3 2 2 3 
3 2 3 2 
3 2 5 
3 3 2 2 
3 5 2 
5 2 3 
5 3 2 
5 5 




// BACKTRACKING & RECURSION - How to Solve Sudoku using Backtracking | Recursion



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool PlaceIsSafe(vector<vector<int>> unsolvedSudoku, int number, int row, int col){
    
    // Horizontally
    for(int i=row, j=col-1; j>=0; j--){
        if(unsolvedSudoku[i][j]==number){
            return false;
        }
    }
    for(int i=row, j=col+1; j<=8; j++){
        if(unsolvedSudoku[i][j]==number){
            return false;
        }
    }
    
    // Vertically
    for(int i=row-1, j=col; i>=0; i--){
        if(unsolvedSudoku[i][j]==number){
            return false;
        }
    }
    for(int i=row+1, j=col; i<=8; i++){
        if(unsolvedSudoku[i][j]==number){
            return false;
        }
    }
    
    
    // everything is done, only this verification is left
    // if %3 = 1 -> -1,+1
    //       = 2 -> -2,+0
    //       = 0 -> -0,+2     in both cases row & col
    
    int startrow, endrow, startcol, endcol;
    // 3x3 submatrix
    if(row%3==0){
        startrow = row;
        endrow = row+2;
    }
    if(col%3==0){
        startcol = col;
        endcol = col+2;
    }
    if(row%3==1){
        startrow = row-1;
        endrow = row+1;
    }
    if(col%3==1){
        startcol = col-1;
        endcol = col+1;
    }
    if(row%3==2){
        startrow = row-2;
        endrow = row;
    }
    if(col%3==2){
        startcol = col-2;
        endcol = col;
    }
    
    for(int i=startrow; i<=endrow; i++){
        for(int j=startcol; j<=endcol; j++){
            if(unsolvedSudoku[i][j]==number){
                return false;
            }
        }
    }
    return true;
}

void Sudoku(vector<vector<int>> unsolvedSudoku, int row, int col){
    
    if(col==9){
        row+=1;
        col=0;
    }
    
    if(row==9 && col==0){
        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                cout<<unsolvedSudoku[i][j]<<" ";
            }
            cout<<endl;
        }
        return;
    }
    

    if(unsolvedSudoku[row][col]==0){
        for(int i=1; i<=9; i++){
            if(PlaceIsSafe(unsolvedSudoku, i, row, col)){
                unsolvedSudoku[row][col]=i;
                Sudoku(unsolvedSudoku, row, col+1);
                unsolvedSudoku[row][col]=0;
            }
        }
    }
    else{
        Sudoku(unsolvedSudoku, row, col+1);
    }
}

int main() {
    vector<vector<int>> unsolvedSudoku{
        {3,0,6,5,0,8,4,0,0},
        {5,2,0,0,0,0,0,0,0},
        {0,8,7,0,0,0,0,3,1},
        {0,0,3,0,1,0,0,8,0},
        {9,0,0,8,6,3,0,0,5},
        {0,5,0,0,9,0,6,0,0},
        {1,3,0,0,0,0,2,5,0},
        {0,0,0,0,0,0,0,7,4},
        {0,0,5,2,0,6,3,0,0}
    };
    cout<<"Enter the values for sudoku: ";
    // for(int i=0; i<9; i++){
    //     vector<int> vect;
    //     int val;
    //     for(int j=0; j<9; j++){
    //         cin>>val;
    //         vect.push_back(val);
    //     }
    //     unsolvedSudoku.push_back(vect);
    // }
    
    cout<<endl<<endl;
    for(int i=0; i<9; i++){
        for(int j=0; j<9; j++){
            cout<<unsolvedSudoku[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl<<endl;
    
    Sudoku(unsolvedSudoku, 0, 0);
}
eg.
Enter the values for sudoku: 

3 0 6 5 0 8 4 0 0 
5 2 0 0 0 0 0 0 0 
0 8 7 0 0 0 0 3 1 
0 0 3 0 1 0 0 8 0 
9 0 0 8 6 3 0 0 5 
0 5 0 0 9 0 6 0 0 
1 3 0 0 0 0 2 5 0 
0 0 0 0 0 0 0 7 4 
0 0 5 2 0 6 3 0 0 


3 1 6 5 7 8 4 9 2 
5 2 9 1 3 4 7 6 8 
4 8 7 6 2 9 5 3 1 
2 6 3 4 1 5 9 8 7 
9 7 4 8 6 3 1 2 5 
8 5 1 7 9 2 6 4 3 
1 3 8 9 4 7 2 5 6 
6 9 2 3 5 1 8 7 4 
7 4 5 2 8 6 3 1 9 




// BACKTRACKING - How to Solve Crossword Puzzle Using Recursion | Backtracking Algorithm



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

bool canPlaceHorizontally(vector<vector<char>> &unsolvedCrossword, int row, int col, string word){
    if(col-1>=0 && unsolvedCrossword[row][col-1]!='+'){
        return false;
    }
    if(col+word.size()<unsolvedCrossword.size() && unsolvedCrossword[row][col+word.size()]!='+'){
        return false;
    }
    for(int i=0; i<word.size(); i++){
        if(col+i>=unsolvedCrossword[0].size()){
            return false;
        }
        if(unsolvedCrossword[row][col+i]=='-' || unsolvedCrossword[row][col+i]==word[i]){
            continue;
        }
        else{
            return false;
        }
    }
    return true;
}

bool canPlaceVertically(vector<vector<char>> &unsolvedCrossword, int row, int col, string word){
    
    if(row-1>=0 && unsolvedCrossword[row-1][col]!='+'){
        return false;
    }
    if(row+word.size()<unsolvedCrossword.size() && unsolvedCrossword[row+word.size()][col]!='+'){
        return false;
    }
    for(int i=0; i<word.size(); i++){
        if(row+i>=unsolvedCrossword[0].size()){
            return false;
        }
        if(unsolvedCrossword[row+i][col]=='-' || unsolvedCrossword[row+i][col]==word[i]){
            continue;
        }
        else{
            return false;
        }
    }
    return true;
}

vector<bool> PlaceHorizontally(vector<vector<char>> &unsolvedCrossword, int row, int col, string word){
    // cout<<word<<endl;
    vector<bool> wePlaced(word.size(), false);
    for(int i=0; i<word.size(); i++){
        if(unsolvedCrossword[row][col+i]=='-'){
            unsolvedCrossword[row][col+i]=word[i];
            wePlaced[i]=true;
        }
    }
    // cout<<endl<<endl;
    // for(int i=0; i<unsolvedCrossword.size(); i++){
    //     for(int j=0; j<unsolvedCrossword.size(); j++){
    //         cout<<unsolvedCrossword[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }
    // for(int i=0; i<wePlaced.size(); i++){
    //     cout<<wePlaced[i]<<" ";
    // }
    // cout<<endl<<endl;
    return wePlaced;
}

vector<bool> PlaceVertically(vector<vector<char>> &unsolvedCrossword, int row, int col, string word){
    // cout<<word<<endl;
    vector<bool> wePlaced(word.size(), false);
    for(int i=0; i<word.size(); i++){
        if(unsolvedCrossword[row+i][col]=='-'){
            unsolvedCrossword[row+i][col]=word[i];
            wePlaced[i]=true;
        }
    }
    // cout<<endl<<endl;
    // for(int i=0; i<unsolvedCrossword.size(); i++){
    //     for(int j=0; j<unsolvedCrossword.size(); j++){
    //         cout<<unsolvedCrossword[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }
    // for(int i=0; i<word.size(); i++){
    //     cout<<wePlaced[i]<<" ";
    // }
    // cout<<endl<<endl;
    return wePlaced;
}

void RemoveHorizontally(vector<vector<char>> &unsolvedCrossword, vector<bool> wePlaced, int row, int col, string word){
    for(int i=0; i<wePlaced.size(); i++){
        if(wePlaced[i]==true){
            unsolvedCrossword[row][col+i]='-';
        }
    }
}

void RemoveVertically(vector<vector<char>> &unsolvedCrossword, vector<bool> wePlaced, int row, int col, string word){
    for(int i=0; i<wePlaced.size(); i++){
        if(wePlaced[i]==true){
            unsolvedCrossword[row+i][col]='-';
        }
    }
}


void CrossWord(vector<vector<char>> unsolvedCrossword, vector<string> words, int index){
    
    if(index==words.size()){
        for(int i=0; i<unsolvedCrossword.size(); i++){
            for(int j=0; j<unsolvedCrossword.size(); j++){
                cout<<unsolvedCrossword[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    
    // cout<<endl<<endl;
    // for(int i=0; i<unsolvedCrossword.size(); i++){
    //     for(int j=0; j<unsolvedCrossword.size(); j++){
    //         cout<<unsolvedCrossword[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }
    // cout<<endl<<endl;
    
    for(int i=0; i<unsolvedCrossword.size(); i++){
        for(int j=0; j<unsolvedCrossword.size(); j++){
            if(unsolvedCrossword[i][j]!='+' || unsolvedCrossword[i][j]==words[index][0]){
                // cout<<i<<" "<<j<<endl;
                if(canPlaceHorizontally(unsolvedCrossword, i, j, words[index])){
                    vector<bool> wePlaced = PlaceHorizontally(unsolvedCrossword, i, j, words[index]);
                    // cout<<endl;
                    // for(int i=0; i<unsolvedCrossword.size(); i++){
                    //     for(int j=0; j<unsolvedCrossword.size(); j++){
                    //         cout<<unsolvedCrossword[i][j]<<" ";
                    //     }
                    //     cout<<endl;
                    // }
                    // cout<<endl;
                    CrossWord(unsolvedCrossword, words, index+1);
                    RemoveHorizontally(unsolvedCrossword, wePlaced, i, j, words[index]);
                }
                if(canPlaceVertically(unsolvedCrossword, i, j, words[index])){
                    vector<bool> wePlaced = PlaceVertically(unsolvedCrossword, i, j, words[index]);
                    // cout<<endl;
                    // for(int i=0; i<unsolvedCrossword.size(); i++){
                    //     for(int j=0; j<unsolvedCrossword.size(); j++){
                    //         cout<<unsolvedCrossword[i][j]<<" ";
                    //     }
                    //     cout<<endl;
                    // }
                    // cout<<endl;
                    CrossWord(unsolvedCrossword, words, index+1);
                    RemoveVertically(unsolvedCrossword, wePlaced, i, j, words[index]);
                }
            }
        }
    }
    
}

int main(){
    cout<<"Enter the incomplete crossword puzzle: "<<endl;
    vector<vector<char>> unsolvedCrossword{
        {'+','-','+','+','+','+','+','+','+','+'},
        {'+','-','+','+','+','+','+','+','+','+'},
        {'+','-','+','+','+','+','+','+','+','+'},
        {'+','-','-','-','-','-','+','+','+','+'},
        {'+','-','+','+','+','-','+','+','+','+'},
        {'+','-','+','+','+','-','+','+','+','+'},
        {'+','+','+','+','+','-','+','+','+','+'},
        {'+','+','-','-','-','-','-','-','+','+'},
        {'+','+','+','+','+','-','+','+','+','+'},
        {'+','+','+','+','+','-','+','+','+','+'},
    };
    
    for(int i=0; i<10; i++){
        for(int j=0; j<10; j++){
            cout<<unsolvedCrossword[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
    cout<<"Enter the words: ";
    vector<string> words;
    string word;
    for(int i=0; i<4; i++){
        cin>>word;
        words.push_back(word);
    }
    cout<<endl;
    
    CrossWord(unsolvedCrossword, words, 0);
    
}

eg.
Enter the incomplete crossword puzzle: 
+ - + + + + + + + + 
+ - + + + + + + + + 
+ - + + + + + + + + 
+ - - - - - + + + + 
+ - + + + - + + + + 
+ - + + + - + + + + 
+ + + + + - + + + + 
+ + - - - - - - + + 
+ + + + + - + + + + 
+ + + + + - + + + + 

Enter the words: antara london delhi iceland
+ l + + + + + + + + 
+ o + + + + + + + + 
+ n + + + + + + + + 
+ d e l h i + + + + 
+ o + + + c + + + + 
+ n + + + e + + + + 
+ + + + + l + + + + 
+ + a n t a r a + + 
+ + + + + n + + + + 
+ + + + + d + + + +




// BACKTRACKING & RECURSION - Cryptarithmetic Puzzle using Backtracking



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int getNum(string str, unordered_map<char, int> um){
    int ans = 0;
    for(int i=0; i<str.size(); i++){
        ans = ans*10 + um[str[i]];
    }
    return ans;
}

void Cryptarithmetic(string str1, string str2, string answer, string uniquestr, int index, unordered_map<char, int> um, vector<bool> usedNumber){
    
    if(index==uniquestr.size()){
        int num1 = getNum(str1, um);
        int num2 = getNum(str2, um);
        int ans = getNum(answer, um);
        if(num1+num2==ans){
            cout<<num1<<" "<<num2<<" "<<ans<<endl;
            for(int i=0; i<26; i++){
                char ch = (char)('a' + i);
                if(um.find(ch)!=um.end()){
                    cout<<ch<<":"<<um[ch]<<" ";
                }
            }
            cout<<endl;
        }
        return;
    }
    
    for(int i=0; i<=9; i++){
        if(usedNumber[i]==false){
            um[uniquestr[index]]=i;
            usedNumber[i]=true;
            Cryptarithmetic(str1, str2, answer, uniquestr, index+1, um, usedNumber);
            um[uniquestr[index]]=-1;
            usedNumber[i]=false;
        }
    }
}

int main(){
    string str1, str2, answer;
    cout<<"Enter first string: ";
    cin>>str1;
    cout<<"Enter second string: ";
    cin>>str2;
    cout<<"Enter answer: ";
    cin>>answer;
    
    string uniquestr="";
    
    unordered_map<char, int> um;
    
    for(int i=0; i<str1.size(); i++){
        if(um.find(str1[i])==um.end()){
            um[str1[i]]=-1;
            uniquestr+=str1[i];
        }
    }
    for(int i=0; i<str2.size(); i++){
        if(um.find(str2[i])==um.end()){
            um[str2[i]]=-1;
            uniquestr+=str2[i];
        }
    }
    for(int i=0; i<answer.size(); i++){
        if(um.find(answer[i])==um.end()){
            um[answer[i]]=-1;
            uniquestr+=answer[i];
        }
    }
    
    cout<<"Uniques string is: "<<uniquestr<<endl;
    
    // unordered_map<char, int>:: iterator itr;
    // for(auto itr=um.begin(); itr!=um.end(); itr++){
    //     cout<<itr->first<<" "<<itr->second<<endl;
    // }
    
    vector<bool> usedNumber(10, false);
    
    Cryptarithmetic(str1, str2, answer, uniquestr, 0, um, usedNumber);

}
eg.
Enter first string: send
Enter second string: more
Enter answer: money
Uniques string is: sendmory
2817 368 3185
d:7 e:8 m:0 n:1 o:3 r:6 s:2 y:5 
2819 368 3187
d:9 e:8 m:0 n:1 o:3 r:6 s:2 y:7 
3712 467 4179
d:2 e:7 m:0 n:1 o:4 r:6 s:3 y:9 
3719 457 4176
d:9 e:7 m:0 n:1 o:4 r:5 s:3 y:6 
3821 468 4289
d:1 e:8 m:0 n:2 o:4 r:6 s:3 y:9 
3829 458 4287
d:9 e:8 m:0 n:2 o:4 r:5 s:3 y:7 
5731 647 6378
d:1 e:7 m:0 n:3 o:6 r:4 s:5 y:8 
5732 647 6379
d:2 e:7 m:0 n:3 o:6 r:4 s:5 y:9 
5849 638 6487
d:9 e:8 m:0 n:4 o:6 r:3 s:5 y:7 
6415 734 7149
d:5 e:4 m:0 n:1 o:7 r:3 s:6 y:9 
6419 724 7143
d:9 e:4 m:0 n:1 o:7 r:2 s:6 y:3 
6524 735 7259
d:4 e:5 m:0 n:2 o:7 r:3 s:6 y:9 
6851 738 7589
d:1 e:8 m:0 n:5 o:7 r:3 s:6 y:9 
6853 728 7581
d:3 e:8 m:0 n:5 o:7 r:2 s:6 y:1 
7316 823 8139
d:6 e:3 m:0 n:1 o:8 r:2 s:7 y:9 
7429 814 8243
d:9 e:4 m:0 n:2 o:8 r:1 s:7 y:3 
7531 825 8356
d:1 e:5 m:0 n:3 o:8 r:2 s:7 y:6 
7534 825 8359
d:4 e:5 m:0 n:3 o:8 r:2 s:7 y:9 
7539 815 8354
d:9 e:5 m:0 n:3 o:8 r:1 s:7 y:4 
7643 826 8469
d:3 e:6 m:0 n:4 o:8 r:2 s:7 y:9 
7649 816 8465
d:9 e:6 m:0 n:4 o:8 r:1 s:7 y:5 
8324 913 9237
d:4 e:3 m:0 n:2 o:9 r:1 s:8 y:7 
8432 914 9346
d:2 e:4 m:0 n:3 o:9 r:1 s:8 y:6 
8542 915 9457
d:2 e:5 m:0 n:4 o:9 r:1 s:8 y:7 
9567 1085 10652
d:7 e:5 m:1 n:6 o:0 r:8 s:9 y:2 




// RECURSION & BACKTRACKING - Gold Mine - II | Path with Maximum Gold - NOT WORKING



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int max=0;

void collectGold(vector<vector<int>> minesAndGold, vector<vector<bool>> visited, int row, int col, int &gold){
    
    if(row<0 || col<0 || row>=minesAndGold.size() || col>=minesAndGold.size() || minesAndGold[row][col]==0 || visited[row][col]==true){
        return;
    }
    
    gold += minesAndGold[row][col];
    visited[row][col]=true;
    collectGold(minesAndGold, visited, row-1, col, gold);       // N
    collectGold(minesAndGold, visited, row, col+1, gold);       // E
    collectGold(minesAndGold, visited, row, col-1, gold);       // W
    collectGold(minesAndGold, visited, row+1, col, gold);       // S 
    
}

void GoldMine2(vector<vector<int>> minesAndGold, vector<vector<bool>> visited, int row, int col){
    
    for(int i=0; i<minesAndGold.size(); i++){
        for(int j=0; j<minesAndGold[i].size(); j++){
            if(visited[i][j]==false && minesAndGold[i][j]!=0){
                // visited[i][j]=true;
                int gold=0;
                collectGold(minesAndGold, visited, row, col, gold);
                // if(gold>max){
                    // max=gold;
                    cout<<gold;
                // }
            }
        }
    }
}

int main(){
    cout<<"Enter the gold mines: "<<endl;
    vector<vector<int>> minesAndGold{
        {10, 0, 100, 200, 0, 8, 0},
        {20, 0, 0, 0, 0, 6, 0},
        {30, 0, 0, 9, 12, 3, 4},
        {40, 0, 2, 5, 8, 3, 11},
        {0, 0, 0, 0, 0, 9, 0},
        {5, 6, 7, 0, 7, 4, 2},
        {8, 9, 10, 0, 1, 10, 8}
    };
    
    vector<vector<bool>> visited(minesAndGold.size(), vector<bool> (minesAndGold.size(), false));
    
    for(int i=0; i<minesAndGold.size(); i++){
        for(int j=0; j<minesAndGold[i].size(); j++){
            cout<<minesAndGold[i][j];
            if(minesAndGold[i][j]<10){
                cout<<"   ";
            }
            else if(minesAndGold[i][j]<100 && minesAndGold[i][j]>=10){
                cout<<"  ";
            }
            else{
                cout<<" ";
            }
        }
        cout<<endl;
    }
    // max=0;
    // cout<<max;
    GoldMine2(minesAndGold, visited, 0, 0);
    // cout<<max;
}




// RECURSION - JOSEPHUS PROBLEM - Game of Execution



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int JosephusProblem(int n, int k){
    if(n==1){
        return 0;
    }
    int x = JosephusProblem(n-1, k);
    int y = (x+k)%n;
    
    return y;
}

int main(){
    int n,k;
    cout<<"Enter the value of n: ";
    cin>>n;
    cout<<"Enter the value of k: ";
    cin>>k;
    
    cout<<JosephusProblem(n, k);
}
eg.
Enter the value of n: 7
Enter the value of k: 4
1



// RECURSION - LEXICOGRAPHICAL PROBLEM



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void LexicographicalProblem(int n, int i){
    if(i>n){
        return;
    }
    
    cout<<i<<" ";
    for(int j=0; j<=9; j++){
        LexicographicalProblem(n, 10*i + j);
    }
    
}

int main(){
    int n;
    cout<<"Enter the value of n: ";
    cin>>n;
    
    for(int i=1; i<=9; i++){
        LexicographicalProblem(n, i);
    }
}
eg.
Enter the value of n: 100
1 10 100 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 26 27 28 29 
3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 
5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 
7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 
9 90 91 92 93 94 95 96 97 98 99 



// BACKTRACKING & RECURSION - 2 Friends Pairing using Backtracking



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void frindsPairProblem(int frind, int totalfrinds, vector<bool> arrivedOrNot, string answer){
    
    if(frind>totalfrinds){
        cout<<answer<<endl;
        return;
    }
    
    if(arrivedOrNot[frind]==true){
        frindsPairProblem(frind+1, totalfrinds, arrivedOrNot, answer);
    }
    else{
        arrivedOrNot[frind]=true;
        frindsPairProblem(frind+1, totalfrinds, arrivedOrNot, answer + "(" + to_string(frind) + ")");
        for(int i=frind+1; i<=totalfrinds; i++){
            if(arrivedOrNot[i]==false){
                arrivedOrNot[i]=true;
                frindsPairProblem(frind+1, totalfrinds, arrivedOrNot, answer + "(" + to_string(frind) + "," + to_string(i) + ")");
                arrivedOrNot[i]=false;
            }
        }
        arrivedOrNot[frind]=false;
    }
    
}

int main(){
    int n;
    cout<<"Enter the number of frinds: ";
    cin>>n;
    string answer="";
    vector<bool> arrivedOrNot(n+1, false);
    
    frindsPairProblem(1, n, arrivedOrNot, answer);
}
eg.
Enter the number of frinds: 4
(1)(2)(3)(4)
(1)(2)(3,4)
(1)(2,3)(4)
(1)(2,4)(3)
(1,2)(3)(4)
(1,2)(3,4)
(1,3)(2)(4)
(1,3)(2,4)
(1,4)(2)(3)
(1,4)(2,3)




// RECURSION & BACKTRACKING - Partition in K Subsets | Recursion & Backtracking


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void PartitionInKSubsets(int n, int val, int k, int setsfilled, vector<vector<int>> answer){
    
    if(val>n){
        if(setsfilled==k){
            for(int i=0; i<answer.size(); i++){
                if(answer[i].size()>0){
                    for(int j=0; j<answer[i].size(); j++){
                        cout<<answer[i][j];
                    }
                    cout<<" | ";
                }
            }
            cout<<endl;
        }
        return;
    }
    
    for(int i=0; i<answer.size(); i++){
        if(answer[i].size()>0){
            answer[i].push_back(val);
            PartitionInKSubsets(n, val+1, k, setsfilled, answer);
            answer[i].pop_back();
        }
        else{
            answer[i].push_back(val);
            PartitionInKSubsets(n, val+1, k, setsfilled+1, answer);
            answer[i].pop_back();
            break;
        }
    }
    
    
}

int main()
{
    int n,k;
    cout<<"Enter the total numbers: ";
    cin>>n;
    cout<<"Enter the subsets: ";
    cin>>k;
    vector<vector<int>> answer(k);
    PartitionInKSubsets(n, 1, k, 0, answer);
    return 0;
}



// RECURSION & BACKTRACKING - Equal Sum Subsets Partition - Recursive | Subset Sum Problem



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void EqualSumPartitionInKSubsets(int n, int val, int k, int setsfilled, vector<vector<int>> answer, vector<int> sumofsubsets){
    
    if(val>n){
        if(setsfilled==k){
            bool flag = true;
            for(int i=0; i<sumofsubsets.size()-1; i++){
                if(sumofsubsets[i]!=sumofsubsets[i+1]){
                    flag=false;
                }
            }
            if(flag==true){
                for(int i=0; i<answer.size(); i++){
                    for(int j=0; j<answer[i].size(); j++){
                        cout<<answer[i][j];
                    }
                    cout<<" | ";
                }
                cout<<endl;
            }
        }
        return;
    }
    
    for(int i=0; i<answer.size(); i++){
        if(answer[i].size()>0){
            answer[i].push_back(val);
            sumofsubsets[i]+=val;
            EqualSumPartitionInKSubsets(n, val+1, k, setsfilled, answer, sumofsubsets);
            sumofsubsets[i]-=val;
            answer[i].pop_back();
        }
        else{
            answer[i].push_back(val);
            sumofsubsets[i]+=val;
            EqualSumPartitionInKSubsets(n, val+1, k, setsfilled+1, answer, sumofsubsets);
            sumofsubsets[i]-=val;
            answer[i].pop_back();
            break;
        }
    }
    
    
}

int main()
{
    int n,k;
    cout<<"Enter the total numbers: ";
    cin>>n;
    cout<<"Enter the subsets: ";
    cin>>k;
    vector<vector<int>> answer(k);
    vector<int> sumofsubsets(k,0);
    if(((n*n + n)/2)%k == 0){
        EqualSumPartitionInKSubsets(n, 1, k, 0, answer, sumofsubsets);
    }
    return 0;
}



// BACKTRACKING & RECURSION - How to Print Abbreviations using Recursion | Backtracking


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void PrintAbbreviation(string str, int index, int val, string answer){
    
    if(index==str.size()){
        if(val>0){
            cout<<answer + to_string(val)<<endl;
        }
        else{
            cout<<answer<<endl;
        }
        return;
    }
    
    PrintAbbreviation(str, index+1, val+1, answer);
    if(val>0){
        string ans = to_string(val) + str[index];
        val=0;
        PrintAbbreviation(str, index+1, val, answer+ans);
    }
    else{
        PrintAbbreviation(str, index+1, val, answer+str[index]);
    }
    
    
}

int main()
{
    string str;
    cout<<"Enter the string: ";
    cin>>str;
    string answer="";
    PrintAbbreviation(str, 0, 0, answer);
}
eg.
Enter the string: pep
3
2p
1e1
1ep
p2
p1p
pe1
pep



// RECURSION & BACKTRACKING - Palindromic Permutations of a String in JAVA | Recursion and Backtracking Algorithm



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void PalindromicPermutation(string newstr, char ch, int index, unordered_map<char, int> um, string answer){
    
    if(index==newstr.size()){
        string revstr = "";
        for(int i=answer.size()-1; i>=0; i--){
            revstr += answer[i];
        }
        if(ch!='0'){
            cout<<answer+ch+revstr<<endl;
        }
        else{
            cout<<answer+revstr<<endl;
        }
    }
    
    unordered_map<char, int>::iterator itr;
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        if(itr->second>0){
            itr->second-=1;
            PalindromicPermutation(newstr, ch, index+1, um, answer+itr->first);
            itr->second+=1;
        }
    }
    
}

int main()
{
    string str;
    cout<<"Enter the string: ";
    cin>>str;
    unordered_map<char, int> um;
    for(int i=0; i<str.size(); i++){
        if(um.find(str[i])!=um.end()){
            um[str[i]]+=1;
        }
        else{
            um[str[i]]=1;
        }
    }
    int odd=0;
    unordered_map<char, int>::iterator itr;
    string newstr = "";
    char ch='0';
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        if(itr->second%2==1){
            odd+=1;
        }
        itr->second/=2;
    }
    for(auto itr=um.begin(); itr!=um.end(); itr++){
        cout<<itr->first<<" "<<itr->second<<endl;
        if(itr->second>0){
            for(int i=0; i<itr->second; i++){
                newstr+=itr->first;
            }
        }
        else{
            ch = itr->first;
        }
    }
    cout<<str<<" "<<newstr<<" "<<ch<<endl;
    if(odd>1){
        return 0;
    }
    else{
        string answer="";
        PalindromicPermutation(newstr, ch, 0, um, answer);
    }
}
eg.
Enter the string: aabbaabbc
c 0
b 2
a 2
aabbaabbc bbaa c
bbaacaabb
babacabab
baabcbaab
abbacabba
ababcbaba
aabbcbbaa



// RECURSION & BACKTRACKING - Word Pattern Matching using Backtracking



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void PatternMatching(string pattern, string str, int index, unordered_map<char, string> um){
    
    if(index==pattern.size()){
        if(str.size()==0){
            unordered_map<char, string>::iterator itr;
            for(auto itr=um.begin(); itr!=um.end(); itr++){
                cout<<itr->first<<":"<<itr->second<<endl;
            }
            cout<<endl;
        }
        return;
    }
    
    if(um.find(pattern[index])!=um.end()){
        string previousmapping = um[pattern[index]];
        if(str.size()>=previousmapping.size()){
            string newmapping = str.substr(0, previousmapping.size());
            string remainingstring = str.substr(previousmapping.size());
            if(newmapping==previousmapping){
                PatternMatching(pattern, remainingstring, index+1, um);
            }
        }
    }
    else{
        for(int i=0; i<str.size(); i++){
            string substring = str.substr(0, i+1);
            um[pattern[index]] = substring;
            string remainingstring = str.substr(i+1);
            PatternMatching(pattern, remainingstring, index+1, um);
            um.erase(pattern[index]);
        }
    }
}

int main()
{
    string pattern, str;
    cout<<"Enter the pattern: ";
    cin>>pattern;
    cout<<"Enter tha string: ";
    cin>>str;
    unordered_map<char, string> um;
    PatternMatching(pattern, str, 0, um);
}
eg.
Enter the pattern: pepe
Enter tha string: glassdoorglassdoor
e:lassdoor
p:g

e:assdoor
p:gl

e:ssdoor
p:gla

e:sdoor
p:glas

e:door
p:glass

e:oor
p:glassd

e:or
p:glassdo

e:r
p:glassdoo




// RECURSION & BACKTRACKING - Word Break Problem using Backtracking


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void WordBreakProblem(unordered_map<string, int> um, string str, vector<string> answer){
    
    if(str.size()==0){
        for(int i=0; i<answer.size(); i++){
            cout<<answer[i]<<" ";
        }
        cout<<endl;
        return;
    }
    
    string prefix="";
    for(int i=0; i<str.size(); i++){
        prefix+=str[i];
        if(um.find(prefix)!=um.end()){
            answer.push_back(prefix);
            WordBreakProblem(um, str.substr(prefix.size()), answer);
            answer.pop_back();
        }
    }    
}

int main()
{
    int words;
    string str;
    cout<<"Enter the no of words: ";
    cin>>words;
    unordered_map<string, int> um;
    cout<<"Enter the words on by one: ";
    string word;
    for(int i=0; i<words; i++){
        cin>>word;
        um[word]=1;
    }
    cout<<"Enter tha string: ";
    cin>>str;
    vector<string> answer;
    WordBreakProblem(um, str, answer);
}
eg.
Enter the no of words: 6
Enter the words on by one: micro soft hi ring microsoft hiring
Enter tha string: microsofthiring
micro soft hi ring 
micro soft hiring 
microsoft hi ring 
microsoft hiring 




// RECURSION & BACKTRACKING - Tug Of War | Minimum Subset Sum Difference


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int minimum = 10000;
vector<int> firstsubset;
vector<int> secondsubset;

int Sum(vector<int> subset){
    int sum = 0;
    for(int i=0; i<subset.size(); i++){
        sum+=subset[i];
    }
    return sum;
}

void MinimumSubsetDifference(vector<int> numbers, int index, vector<vector<int>> answer){
    
    if(index==numbers.size()){
        
        if(fabs(answer[0].size() - answer[1].size()) <= 1){      // float absolute
            int firstsubsetsum = Sum(answer[0]);
            int secondsubsetsum = Sum(answer[1]);
            
            if(abs(firstsubsetsum - secondsubsetsum)<minimum){
                minimum = abs(firstsubsetsum - secondsubsetsum);
                firstsubset = answer[0];
                secondsubset = answer[1];
            }
        }
        return;
    }
    
    for(int i=0; i<=1; i++){
        answer[i].push_back(numbers[index]);
        MinimumSubsetDifference(numbers, index+1, answer);
        answer[i].pop_back();
    }
    
}

int main()
{
    int n, number;
    vector<int> numbers;
    cout<<"Enter the number: ";
    cin>>n;
    cout<<"Enter the numbers from 1 to "<<n<<" one by one: ";
    for(int i=1; i<=n; i++){
        cin>>number;
        numbers.push_back(number);
    }
    vector<vector<int>> answer(2);
    MinimumSubsetDifference(numbers, 0, answer);
    for(int i=0; i<firstsubset.size(); i++){
        cout<<firstsubset[i]<<",";
    }
    cout<<endl;
    for(int i=0; i<secondsubset.size(); i++){
        cout<<secondsubset[i]<<",";
    }
    cout<<endl<<minimum;
}
eg.
Enter the number: 7
Enter the numbers from 1 to 7 one by one: 1 2 3 4 5 6 7
1,2,4,7,
3,5,6,
0



// RECURSION & BACKTRACKING - Maximum Number after K Swaps - NOT WORKING CORRECT FOR GREATER K



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

long long int maximum = 0;

void Swap(vector<char> &characters, int i, int j){
    char ans = characters[i];
    characters[i] = characters[j];
    characters[j] = ans;
}

void MaximumNumberAfterKSwaps(vector<char> characters, int k, int swap){
    
    if(k==swap){
        long long int ans = 0;
        for(int i=0; i<characters.size(); i++){
            ans = 10*ans + ( characters[i] - '0' );
        }
        if(ans>maximum){
            maximum = ans;
            cout<<maximum<<" ";
        }
        return;
    }
    
    for(int i=0; i<characters.size()-1; i++){
        for(int j=i+1; j<characters.size(); j++){
            if(characters[i] - '0' < characters[j] - '0'){
                Swap(characters, i, j);
                MaximumNumberAfterKSwaps(characters, k, swap+1);
                Swap(characters, i, j);
            }
        }
    }
    
}

int main()
{
    string str;
    int k;
    vector<char> characters;
    cout<<"Enter the string: ";
    cin>>str;
    cout<<"Enter the no of swaps: ";
    cin>>k;
    for(int i=0; i<str.size(); i++){
        characters.push_back(str[i] );
    }
    for(int i=0; i<characters.size(); i++){
        cout<<characters[i];
    }
    cout<<endl;
    MaximumNumberAfterKSwaps(characters, k, 0);
    cout<<endl<<maximum;
}
eg.
Enter the string: 1234567
Enter the no of swaps: 4
1234567

7654312




// RECURSION - Remove Invalid Parentheses Explained using Stacks (Valid Parentheses)


#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int MinimumRemoval(string str){
    stack<char> st;
    for(int i=0; i<str.size(); i++){
        if(str[i]=='('){
            st.push('(');
        }
        else{
            if(st.size()==0 || st.top()==')'){
                st.push(')');
            }
            else{
                st.pop();
            }
        }
    }
    return st.size();
}

void RemoveInvalidParentesis(string str, int removalSoFar, int minremoval, set<string> &validParenthesis){
    
    if(removalSoFar==minremoval){
        if(MinimumRemoval(str) == 0){
            set<string>::iterator itr;
            if(validParenthesis.find(str) == validParenthesis.end()){
                validParenthesis.insert(str);
                cout<<str<<endl;
            }
        }
        return;
    }
    
    for(int i=0; i<str.size(); i++){
        string first = str.substr(0, i);
        string second = str.substr(i+1);
        RemoveInvalidParentesis(first+second, removalSoFar+1, minremoval, validParenthesis);
    }
    
}



int main()
{
    string str;
    cout<<"Enter the parenthesis string: ";
    cin>>str;
    
    int minremoval = MinimumRemoval(str);
    set<string> validParenthesis;
    RemoveInvalidParentesis(str, 0, minremoval, validParenthesis);
}
eg.
Enter the parenthesis string: ()())()
(())()
()()()




// BACKTRACKING & RECURSION - Magnets - Most Interesting Problem Of BackTracking - NOT WORKING



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int rowcount(char ch, vector<vector<char>> &Answer, int currow){
    int count = 0;
    for(int i=0; i<Answer[currow].size(); i++){
        if(Answer[currow][i]==ch){
            count++;
        }
    }
    return count;
}

int colcount(char ch, vector<vector<char>> &Answer, int curcol){
    int count = 0;
    for(int i=0; i<Answer.size(); i++){
        if(Answer[i][curcol]==ch){
            count++;
        }
    }
    return count;
}

bool isSafe(char ch, int currow, int curcol, vector<vector<char>> &Answer, vector<int> top, 
            vector<int> left, vector<int> bottom, vector<int> right){
    
    cout<<ch<<endl;
    for(int i=0; i<5; i++){
        for(int j=0; j<6; j++){
            cout<<Answer[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
    
    if((Answer[currow][curcol-1]==ch && curcol-1>=0) || (Answer[currow-1][curcol]==ch && currow-1>=0) || 
       (Answer[currow][curcol+1]==ch && curcol+1<Answer[0].size())){
        cout<<"FAIL"<<endl;
        return false;
    }
    if(ch=='+'){
        cout<<"2nd step"<<endl;
        int rcount = rowcount(ch, Answer, currow);
        int ccount = colcount(ch, Answer, curcol);
        
        if(rcount>=left[currow] && left[currow]!=-1){
            cout<<"FAIL"<<endl;
            return false;
        }
        if(ccount>=top[curcol] && top[curcol]!=-1){
            cout<<"FAIL"<<endl;
            return false;
        }
    }
    else if(ch=='-'){
        int rcount = rowcount(ch, Answer, currow);
        int ccount = colcount(ch, Answer, curcol);
        
        if(rcount>=right[currow] && right[currow]!=-1){
            cout<<"FAIL"<<endl;
            return false;
        }
        if(ccount>=bottom[curcol] && bottom[curcol]!=-1){
            cout<<"FAIL"<<endl;
            return false;
        }
    }
    cout<<"Pass"<<endl;
    return true;
}

bool isValidAnswer(vector<vector<char>> &Answer, vector<int> top,
                    vector<int> left, vector<int> bottom, vector<int> right){
    
    for(int i=0; i<top.size(); i++){
        int count = colcount('+', Answer, i);
        if(count!=top[i] && top[i]!=-1){
            return false;
        }
    }
    for(int i=0; i<left.size(); i++){
        int count = rowcount('+', Answer, i);
        if(count!=left[i] && left[i]!=-1){
            return false;
        }
    }
    for(int i=0; i<bottom.size(); i++){
        int count = colcount('-', Answer, i);
        if(count!=bottom[i] && bottom[i]!=-1){
            return false;
        }
    }
    for(int i=0; i<right.size(); i++){
        int count = colcount('-', Answer, i);
        if(count!=right[i] && right[i]!=-1){
            return false;
        }
    }
    
    return true;
    
}

bool MagnetsProblem(vector<vector<char>> &MagnetBox, vector<vector<char>> &Answer, vector<int> top,
                    vector<int> left, vector<int> bottom, vector<int> right, int currow, int curcol){
    
    for(int i=0; i<5; i++){
        for(int j=0; j<6; j++){
            cout<<Answer[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
    
    if(curcol>=Answer[currow].size()){
        currow+=1;
        curcol=0;
    }
    
    if(currow==Answer.size()){
        if(isValidAnswer(Answer, top, left, bottom, right)){
            return true;
        }
        return false;
    }
    
    if(MagnetBox[currow][curcol]=='L'){
        cout<<"1st step"<<endl;
        if(isSafe('+', currow, curcol, Answer, top, left, bottom, right) && 
           isSafe('-', currow, curcol+1, Answer, top, left, bottom, right)){
            Answer[currow][curcol] = '+';
            Answer[currow][curcol+1] = '-';
            if(MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, currow, curcol+2)){
                return true;
            }
            Answer[currow][curcol] = 'X';
            Answer[currow][curcol+1] = 'X';
        }
        else if(isSafe('-', currow, curcol, Answer, top, left, bottom, right) && 
                isSafe('+', currow, curcol+1, Answer, top, left, bottom, right)){
            Answer[currow][curcol] = '-';
            Answer[currow][curcol+1] = '+';
            if(MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, currow, curcol+2)){
                return true;
            }
            Answer[currow][curcol] = 'X';
            Answer[currow][curcol+1] = 'X';
        }
    }
    
    else if(MagnetBox[currow][curcol]=='T'){
        if(isSafe('+', currow, curcol, Answer, top, left, bottom, right) && 
           isSafe('-', currow+1, curcol, Answer, top, left, bottom, right)){
            Answer[currow][curcol] = '+';
            Answer[currow+1][curcol] = '-';
            if(MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, currow, curcol+1)==true){
                return true;
            }
            Answer[currow][curcol] = 'X';
            Answer[currow+1][curcol] = 'X';
        }
        else if(isSafe('-', currow, curcol, Answer, top, left, bottom, right) && 
                isSafe('+', currow+1, curcol, Answer, top, left, bottom, right)){
            Answer[currow][curcol] = '-';
            Answer[currow+1][curcol] = '+';
            if(MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, currow, curcol+1)==true){
                return true;
            }
            Answer[currow][curcol] = 'X';
            Answer[currow+1][curcol] = 'X';
        }
    }
    bool ans = MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, currow, curcol+1);
    if(ans==true){
        return true;
    }
    return false;
}

int main()
{
    int row, col;
    cout<<"Enter the size of the magnet box: ";
    cin>>row>>col;
    
    // vector<vector<char>> MagnetBox;
    // cout<<"Enter the values of the magnet box:"<<endl;
    // for(int i=0; i<row; i++){
    //     vector<char> rows;
    //     char cols;
    //     for(int j=0; j<col; j++){
    //         cin>>cols;
    //         rows.push_back(cols);
    //     }
    //     MagnetBox.push_back(rows);
    // }
    vector<vector<char>> MagnetBox{
        {'L','R','L','R','T','T'},
        {'L','R','L','R','B','B'},
        {'T','T','L','R','L','R'},
        {'B','B','L','R','T','T'},
        {'L','R','L','R','B','B'}
    };
    cout<<"MagnetBox is: "<<endl;
    for(int i=0; i<row; i++){
        for(int j=0; j<col; j++){
            cout<<MagnetBox[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
    
    
    // vector<vector<char>> Answer;
    // for(int i=0; i<row; i++){
    //     vector<char> rows;
    //     for(int j=0; j<col; j++){
    //         rows.push_back('X');
    //     }
    //     Answer.push_back(rows);
    // }
    vector<vector<char>> Answer{
        {'X','X','X','X','X','X'},
        {'X','X','X','X','X','X'},
        {'X','X','X','X','X','X'},
        {'X','X','X','X','X','X'},
        {'X','X','X','X','X','X'}
    };
    cout<<"Answer is: "<<endl;
    for(int i=0; i<row; i++){
        for(int j=0; j<col; j++){
            cout<<Answer[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;
    
    // vector<int> top;
    // vector<int> left;
    // vector<int> bottom;
    // vector<int> right;
    
    // int n;
    // cout<<"Enter top values: ";
    // for(int i=0; i<col; i++){
    //     cin>>n;
    //     top.push_back(n);
    // }
    // cout<<"Enter left values: ";
    // for(int i=0; i<row; i++){
    //     cin>>n;
    //     left.push_back(n);
    // }
    // cout<<"Enter bottom values: ";
    // for(int i=0; i<col; i++){
    //     cin>>n;
    //     bottom.push_back(n);
    // }
    // cout<<"Enter right values: ";
    // for(int i=0; i<row; i++){
    //     cin>>n;
    //     right.push_back(n);
    // }
    
    vector<int> top{1, -1, -1, 2, 1, -1};
    vector<int> left{2, 3, -1, -1, -1};
    vector<int> bottom{2, -1, -1, 2, -1, 3};
    vector<int> right{-1, -1, -1, 1, -1};
    
    cout<<"top values: ";
    for(int i=0; i<col; i++){
        cout<<top[i]<<" ";
    }
    cout<<endl;
    cout<<"left values: ";
    for(int i=0; i<row; i++){
        cout<<left[i]<<" ";
    }
    cout<<endl;
    cout<<"bottom values: ";
    for(int i=0; i<col; i++){
        cout<<bottom[i]<<" ";
    }
    cout<<endl;
    cout<<"right values: ";
    for(int i=0; i<row; i++){
        cout<<right[i]<<" ";
    }
    cout<<endl;
    if(MagnetsProblem(MagnetBox, Answer, top, left, bottom, right, 0, 0) == true){
        cout<<"Updated Answer is: "<<endl;
        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                cout<<Answer[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
    }
    else{
        cout<<"No solution exist";
    }
    cout<<"THE END";
}
eg.
Enter the size of the magnet box: 5 6
MagnetBox is: 
L R L R T T 
L R L R B B 
T T L R L R 
B B L R T T 
L R L R B B 

Answer is: 
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 

top values: 1 -1 -1 2 1 -1 
left values: 2 3 -1 -1 -1 
bottom values: 2 -1 -1 2 -1 3 
right values: -1 -1 -1 1 -1 
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 

1st step
+
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 
X X X X X X 



// RECURSION & BACKTRACKING - MAX SCORE OF WORDS



#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int maximum = 0;

int WordsSum(vector<string> answer, unordered_map<char, int> um, unordered_map<char, int> scores){
    int count = 0;
    bool valid = true;
    for(int i=0; i<answer.size(); i++){
        for(int j=0; j<answer[i].size(); j++){
            if(um[answer[i][j]]>0){
               count += scores[answer[i][j]];
               um[answer[i][j]]-=1;
            }
            else{
                valid = false;
                break;
            }
        }
    }
    if(valid==true){
        return count;
    }
    else{
        return 0;
    }
}

void MaximumSumOfWords(int index, vector<string> words, unordered_map<char, int> um, unordered_map<char, int> scores, vector<string> answer){
    
    if(index==words.size()){
        return;
    }
    
    int ans = WordsSum(answer, um, scores);
    if(ans>maximum){
        maximum = ans;
    }
    
    MaximumSumOfWords(index+1, words, um, scores, answer);
    answer.push_back(words[index]);
    for(int i=0; i<answer.size(); i++){
        cout<<answer[i]<<" ";
    }
    cout<<endl;
    MaximumSumOfWords(index+1, words, um, scores, answer);
    answer.pop_back();
}

int main(){
    int n;
    cout<<"Enter number of words: ";
    cin>>n;
    vector<string> words;
    string word;
    for(int i=0; i<n; i++){
        cin>>word;
        words.push_back(word);
    }
    int characters;
    cout<<"Enter the no characters: ";
    cin>>characters;
    char ch;
    unordered_map<char, int> um;
    for(int i=0; i<characters; i++){
        cin>>ch;
        if(um.find(ch)!=um.end()){
            um[ch] += 1;
        }
        else{
            um[ch] = 1;
        }
    }
    unordered_map<char, int> scores;
    scores['a'] = 1;
    scores['c'] = 9;
    scores['d'] = 5;
    scores['g'] = 3;
    scores['o'] = 2;
    scores['t'] = 0;
    
    vector<string> answer;
    MaximumSumOfWords(0, words, um, scores, answer);
    cout<<maximum;
}
eg.
Enter number of words: 4
dad cat good dog
Enter the no characters: 9
a b c d d d g o o
dog 
good 
good dog 
cat 
cat dog 
cat good 
cat good dog 
dad 
dad dog 
dad good 
dad good dog 
dad cat 
dad cat dog 
dad cat good 
dad cat good dog 
23